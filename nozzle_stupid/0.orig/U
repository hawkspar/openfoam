/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  dev
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       volVectorField;
    object	U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 1 -1 0 0 0 0];

internalField #codeStream //Use codeStream to set the value of the initial conditions
{
    codeInclude
    #{
        #include "fvCFD.H"
        #include "math.h"
    #};
    codeOptions
    #{
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude
    #};
    codeLibs
    #{
        -lmeshTools \
        -lfiniteVolume
    #};
    //Depending of what are you trying to do, you will need to add new files, options and libraries.
    //For most of the cases, this part is always the same.

    code //Insert your code here. At this point, you need to know how to access internal mesh information
    #{
        const IOdictionary& d = static_cast<const IOdictionary&>(dict);
        const fvMesh& mesh = refCast<const fvMesh>(d.db());
	const vectorField& CC = mesh.C(); //cell center 

	const scalar U_M = 10;
	const scalar U_m = .1;
	const scalar R = .1;
	const scalar r1 = 5*R;
	vectorField U(mesh.nCells(), vector(0,0,0));
        forAll(U, i)
        {
		// Access cell centers coordinates
		const scalar y = CC[i].y();
		const scalar z = CC[i].z();
		const scalar r=sqrt(y*y+z*z);
		if (r<R) {
			U[i][0] = U_M*tanh(4*(1-r*r/R/R));
		}
		else if (r>R) {
			U[i][0] = U_m*tanh(4*(1-(r-R)*(r-R)/(r1-R)/(r1-R)));
		}
        }
        U.writeEntry("", os);
    #};
};;

boundaryField
{
    inlet
    {
	type codedFixedValue;
	value uniform (0 0 0);
	name inletLaminarProfile;
	
	codeInclude
	#{
		#include "math.h"
	#};

	code
	#{
		const fvPatch& boundaryPatch = patch();
		const vectorField& Cf = boundaryPatch.Cf();
		const scalar U_M = 10;
		const scalar R = .1;
		forAll(Cf, faceI) {
			const scalar y = Cf[faceI].y();
			const scalar z = Cf[faceI].z();
			const scalar r2=y*y+z*z;
			(*this)[faceI] = vector(U_M*tanh(4*(1-r2/R/R)),0,0);
		}
	#};
    }

    front
    {
        type empty;
    }

    back
    {
        type empty;
    }

    wall
    {
        type noSlip;
    }

    coflow
    {
	type codedFixedValue;
	value uniform (0 0 0);
	name coflowLaminarProfile;
	
	codeInclude
	#{
		#include "math.h"
	#};

	code
	#{
		const fvPatch& boundaryPatch = patch();
		const vectorField& Cf = boundaryPatch.Cf();
		const scalar U_m = .1;
		const scalar R = .1;
		const scalar r1 = 5*R;
		forAll(Cf, faceI) {
			const scalar y = Cf[faceI].y();
			const scalar z = Cf[faceI].z();
			const scalar r=sqrt(y*y+z*z);
			(*this)[faceI] = vector(U_m*tanh(4*(1-(r-R)*(r-R)/(r1-R)/(r1-R))),0,0);
		}
	#};
    }

    far
    {
        type fixedValue;
        value uniform (.1 0 0);
    }

    bottom
    {
        type fixedValue;
        value uniform (10 0 0);
    }

    outlet
    {
	type zeroGradient;
    }

}

// ************************************************************************* //
